# MYSQL为什么用B+树

## 二叉树

一次递增的Id查找起来和全表扫描没什么区别

## 红黑树（AVL树)

性质1. 结点是红色或黑色。 

性质2. 根结点是黑色。

性质3. 所有叶子都是黑色。（叶子是NIL结点） 

性质4. 每个红色结点的两个子结点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色结点）

性质5. 从任一节结点其每个叶子的所有路径都包含相同数目的黑色结点。

数据量很大的时候，索引的体积也会很大，可能内存放不下，所以需要从磁盘上进行相关读写，如果树的层级太高，则读写磁盘的次数（I/O交互）就会越多，性能就会越差。

## B树

度（Degree）：一个节点拥有的子节点（子树）的数量。（有的地方是以**度**来说明 `B-tree` 的，这里解释一下）

阶（order）：一个节点的子节点的最大个数。（通常用 **m** 表示）

1. 除根节点和叶子节点外，其它每个节点至少有 个子节点；

    为 m / 2 然后向上取整

2. 每个非根节点所包含的关键字个数 j 满足： - 1 ≤ j ≤ m - 1；

3. 节点的关键字从左到右递增排列，有 k 个关键字的非叶子节点正好有 (k + 1) 个子节点；

4. 所有的叶子结点都位于同一层。

### 插入操作

1. 根据要插入的**关键字**查找到待插入的叶子节点；

2. 因为一个节点的子节点的最大个数（阶）为 m，所以需要判断当前节点**关键字**的个数是否小于 (m - 1)。

3. - 是：直接插入
   - 否：发生**节点分裂**，以节点的中间的关键字将该节点分为左右两部分，中间的关键字放到父节点中即可。

### 删除操作

1. 直接删
2. 删除叶子节点元素合并+旋转
3. 删除非叶子节点元素合并+旋转

B树节点中不仅存储键值，也会存储数据。子节点数据不出现在父节点上

![img](https://pic2.zhimg.com/80/v2-2c2264cc1c6c603dfeca4f84a2575901_720w.jpg)

## B+Tree

`B+tree` 和 `B-tree` 区别：

1. 所有的子节点，一定会出现在叶子节点上
2. 相邻的叶子节点之间，会用一个**双向链表**连接起来
3. 非叶子节点只存储索引，不存储数据，就为放更多索引

- B+tree 中间节点没有数据，只有索引；这就意味着相同大小的磁盘页可以放更多的节点元素，也就是在相同的数据量下，I/O 操作更少

- B+tree 因为叶子节点通过双向链表进行连接，找到指定范围内的下限后，直接通过链表顺序遍历就行，这样就方便很多了。

- 树的高度可控

innodb必须有一个聚簇索引，没有指定主键就会自动生成6字节的row_id。myisam的节点存放的是记录的磁盘地址。

B+树不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖

**一个节点相当于一个磁盘块，大小16KB，由4页组成。三层为16\*16\*16 = 4096KB,一个磁盘块存指针和索引。指针固定大小，索引尽量用最小空间的数据类型。主键自增会累加插入B+树，效率很高，减少节点分裂**

