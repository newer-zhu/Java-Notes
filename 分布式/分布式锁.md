## redis

多线程轮循加锁会导致网络IO频繁，加上timeout防止获得锁线程挂了造成死锁。此外还应该引入一个监控线程防止线程未完成任务就释放了锁，redission做了实现。

```bash
SET lockKey uniqueValue EX 3 NX
```

- **lockKey** ：加锁的锁名；
- **uniqueValue** ：能够唯一标示锁的随机字符串；
- **NX** ：只有当 lockKey 对应的 key 值不存在的时候才能 SET 成功；
- **EX** ：过期时间设置（秒为单位）EX 3 标示这个锁有一个 3 秒的自动过期时间。与 EX 对应的是 PX（毫秒为单位），这两个都是过期时间设置。

------

获得锁的线程应该开一个阻塞队列将没抢到锁的线程放入队列，防止频繁IO

#### redis集群下怎么办？

Redis 集群下，由于 Redis 集群数据同步到各个节点时是异步的，如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁

**RedLock**

Redlock 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。

Redlock 实现比较复杂，性能比较差，发生时钟变迁的情况下还存在安全性隐患。

------

## zookeeper

### 读锁

1. 创建临时节点，数据是read表示读锁

2. 获取zk中序号比自己小的所有节点

3. 判断最小节点是否是读锁

- 不是读锁上锁失败，为最小节点设置监听。阻塞等待，watch机制会保证当最小节点变化时通知当前节点，再次执行第二步

- 是读锁则上锁成功

### 写锁  

1. 创建临时节点，数据是write表示写锁
2. 获取zk中所有write节点
3. 判断自己是不是最小节点

- 是则上锁成功

- 不是说明还有锁，监听最小节点，有变化则退到第2步

如果等待监听节点过多的话会对zk有较大压力，此时可以链式监听，即监听上一个节点

