## 作用

**异步处理、服务解耦、流量控制**

## 架构模型

1. **Message**

   它由**消息头和消息体**组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 `routing-key`、`priority`、`delivery-mode`（指出该消息可能需要持久性存储）等。

2. **Exchange**

   接收生产者发送的消息并将这些消息路由给服务器中的队列

3. **Binding**

   用于消息队列和交换器之间的关联

4. **Queue**

   用于存储消息消息的容器

5. **Connection**

   一个网络连接

6. **Channel**

   信道，多路复用连接中的一条独立的**双向数据流**通道。信道是建立在真实的 `TCP` 连接内地虚拟连接，`AMQP` 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 `TCP`都是非常昂贵的开销，所以引入了信道的概念，以**复用**一条 `TCP` 连接。

7. **Consumer**

8. **Publisher**

9. **Virtual Host**

   虚拟主机，表示一批交换器、消息队列和相关对象

10. **Broker**

    消息队列服务器实体

总结一下整体过程：生产者投递消息 -> 和Server建立连接，开启信道 -> 声明交换器和队列，并通过路由键将交换机和队列绑定 -> 投递消息到虚拟主机 -> 消息发送到消息队列 -> 消费者建立连接 -> 消费消息 -> 关系信道和连接。

## Exchange类型

- direct：路由键匹配点对点
- fanout：忽略路由键广播，fanout 类型转发消息是最快的
- header：和direct差不多，不常用。它的路由不是用routingKey进行路由匹配，而是在匹配请求头中所带的键值进行路由
- topic：根据路由键匹配规则

## 高级特性

**过期时间**

- RabbitMQ可以对消息和队列设置TTL。

- RabbitMQ支持设置消息的过期时间，在消息发送的时候可以进行指定，每条消息的过期时间可以不同。
- RabbitMQ支持设置队列的过期时间，从消息入队列开始计算，直到超过了队列的超时时间配置，那么消息会变成死信，自动清除。
- 如果两种方式一起使用，则过期时间以两者中较小的那个数值为准。
- 当然也可以不设置TTL，不设置表示消息不会过期；如果设置为0，则表示除非此时可以直接将消息投递到消费者，否则该消息将被立即丢弃。

**消息确认**

消息确认机制是RabbitMQ消息可靠性投递的基础，只要设置autoAck参数为false，消费者就有足够的时间处理消息，不用担心处理消息的过程中消费者进程挂掉后消息丢失的问题。

**持久化**

持久化可以防止在异常情况下丢失数据。RabbitMQ的持久化分为三个部分：交换器持久化、队列持久化和消息的持久化。

如果交换器不设置持久化，那么在RabbitMQ服务重启之后，相关的交换器元数据会丢失，不过消息不会丢失，只是不能将消息发送到这个交换器了。

队列的持久化能保证其本身的元数据不会因异常情况而丢失，但是不能保证内部所存储的消息不会丢失。要确保消息不会丢失，需要将其设置为持久化。队列的持久化可以通过在声明队列时将durable参数设置为true。

设置了队列和消息的持久化，当RabbitMQ服务重启之后，消息依然存在。如果只设置队列持久化或者消息持久化，重启之后消息都会消失。

当然，也可以将所有的消息都设置为持久化，但是这样做会影响RabbitMQ的性能。对于可靠性不是那么高的消息可以不采用持久化处理以提高整体的吞吐量。在实际中，需要根据实际情况在可靠性和吞吐量之间做一个权衡。

### 延迟队列

延迟队列就是进入该队列的消息会被消费者延迟消费，延迟队列中存储的对象是的延迟消息，“延迟消息”是指当消息被发送以后，等待特定的时间后，消费者才能拿到这个消息进行消费。

延迟队列用于需要延迟工作的场景。最常见的使用场景：用户在下单之后通常有30分钟的时间进行支付，如果这30分钟之内没有支付成功，那么订单就会自动取消。除了延迟消费，延迟队列的典型应用场景还有延迟重试。比如消费者从队列里面消费消息失败了，可以延迟一段时间以后进行重试。

## 消息丢失

**生产者  -> Broker**

不论是同步还是异步发送消息，同步和异步回调都需要做好`try-catch`，妥善的处理响应，如果`Broker`返回写入失败等错误消息，需要重试发送。当多次发送失败需要作报警，日志记录等

**Broker储存消息**

存储消息阶段需要在**消息刷盘之后**再给生产者响应，假设消息写入缓存中就返回响应，那么机器突然断电这消息就没了，而生产者以为已经发送成功了。

**Broker -> 消费者**

消费者真正执行完业务逻辑之后，再发送给`Broker`消费成功，这才是真正的消费了

关闭自动确认，开启手动确认

basic.ack 用于肯定确认 

basic.nack 用于否定确认

basic.reject 用于否定确认，但与basic.nack相比有一个限制:一次只能拒绝单条消息 

channel.basicReject(deliveryTag, true)

拒绝消费当前消息，如果第二参数传入true，就是将数据重新丢回队列里，那么下次还会消费这消息。设置false，就是告诉服务器，我已经知道这条消息数据了，因为一些原因拒绝它，而且服务器也把这个消息丢掉就行。

使用拒绝后重新入列这个确认模式要谨慎，如果使用不当会导致每次被你重入列的消息一直消费-入列-消费-入列这样循环，会导致消息积压。

channel.basicNack(deliveryTag, false, true);

- 第一个参数依然是当前消息到的数据的唯一id;

- 第二个参数是指是否针对多条消息；如果是true，也就是说一次性针对当前通道的消息的tagID小于当前这条消息的，都拒绝确认。

- 第三个参数是指是否重新入列

channel.basicQos(1) //一次发一条消息给消费者

channel.basicAck(envelope.getDeliveryTag(),false) //手动确认消息标识，每次确认一个

## 重复消息

正常业务而言**消息重复是不可避免的**，因此我们只能从**另一个角度**来解决重复消息的问题。

### 幂等性

1. 改造业务处理逻辑，使得在重复消息的情况下也不会影响最终的结果
2. 数据库的约束例如唯一键
3. 其他方法也是靠唯一性来解决

## 有序性

### 全局有序

基本不需要，这样只能一个消费者往topic发消息且只有一个队列

### 局部有序

把消息通过特定的策略发往固定的队列中，然后每个队列对应一个单线程处理的消费者。这样即完成了部分有序的需求，又可以通过队列数量的并发来提高消息处理效率。

## 消息堆积

水平扩容：增加`Topic`的队列数和消费者数量，**注意队列数一定要增加**，不然新增加的消费者是没东西消费的。**一个Topic中，一个队列只会分配给一个消费者**。

