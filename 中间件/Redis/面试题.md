### 过期问题？

**主动和被动**

主动过期，redis每秒随机检查20个key，删除过期的key，如果过期的key多于检测的25%，继续挑选20个key，重复以上步骤。保证任何时刻都有25%的key过期

被动过期，用到一个key之前会检测是否过期

**过期时间？**

过期事件用的是unix的时间戳，保证redis挂了设置的时间依旧流逝。如果两台服务器时钟不一致，RDB在两台服务器之间同步，所有key装载时就过期

**复制AOF文件时如何处理过期？**

![image-20220316145837020](E:\学习笔记\typora\img\image-20220316145837020.png)

**回收策略**

![image-20220316151005478](E:\学习笔记\typora\img\image-20220316151005478.png)

### 单线程模型

1. Redis基于Reactor模式开发了网络事件处理器,这个处理器就叫做文件事件处理器(file event handler).这个文件事件处理器是单线程的,所以Redis才叫做单线程的模型,文件事件处理器采用了IO多路复用机制同时监听多个socket,根据socket上的事件来选择对应的事件处理器来处理这个事件;

2. 如果被监听的[socket](https://so.csdn.net/so/search?q=socket&spm=1001.2101.3001.7020)准备好执行accept,read,write,close等事件/操作的时候,对应的文件事件就会产生,这个时候文件事件处理器就会调用之前关联好的事件处理器来处理这个事件;

3. 文件事件处理器是单线程模式运行的,但是通过IO多路复用机制监听多个socket,可以实现高性能的网络通信模型.又可以跟内部其他单线程的模块进行对接,保证了Redis内部的线程模型的简单性;

4. 文件事件处理器的结构包含4个部分

   > ①.多个socket;
   >
   > ②.IO多路复用程序;
   >
   > ③.文件事件分派器;
   >
   > ④.事件处理器(命令请求处理器,命令回复处理器,连接应答处理器等等);

5. 多个socket可能并发的产生不同的操作,每个操作对应不同的文件事件,但是IO多路复用程序会监听多个socket,会将socket放入一个队列中排队,然后每次从队列中取出一个socket给事件分派器,事件分派器再把socket分派给对应的事件处理器去处理;
6. 当一个socket的事件被处理完之后,IO多路复用程序才会将队列中的下一个socket取出交给事件分派器.文件事件分派器再根据socket当前产生的事件来选择对应的事件处理器来处理;

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190918215924363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hwX3hweHA=,size_16,color_FFFFFF,t_70)

### 分布式

### redis底层实现数据结构

![](E:\学习笔记\typora\img\redisb.png)

string：编码分为int、raw、embstr；int底层实现为long,当数据为整数型并且可以用long类型表示时可以用

long存储；embstr底层实现为占一块内存的SDS结构,当数据为长度不超过32字节的字符串时,选择以此结构连续存储元数据和值；raw底层实现为占两块内存的SDS,用于存储长度超过32字节的字符串数据,此时会在两块内存中分别存储元数据和值。 

list：编码分为ziplist、linkedlist和quicklist（3.2以前版本没有quicklist）。ziplist底层实现为压缩列表,当元素数量小于2且所有元素长度都小于64字节时,使用这种结构来存储；linkedlist底层实现为双端链表,当数据不符合ziplist条件时,使用这种结构存储；3.2版本之后list一般采用quicklist的快速列表结构来代替前两种。

 hash：编码分为ziplist、hashtable两种,其中ziplist底层实现为压缩列表,当键值对数量小于2,并且所有的键值长度都小于64字节时使用这种结构进行存储；hashtable底层实现为字典,当不符合压缩列表存储条件时,使用字典进行存储。 

set：编码分为inset和hashtable,intset底层实现为整数集合,当所有元素都是整数值且数量不超过2个时使用该结构存储,否则使用字典结构存储。

 zset：编码分为ziplist和skiplist,当元素数量小于128,并且每个元素长度都小于64字节时,使用ziplist压缩列表结构存储,否则使用skiplist的字典+跳表的结构存储

### redis用作消息队列

![image-20220505223722201](E:\学习笔记\typora\img\image-20220505223722201.png)

### 缓存击穿、穿透、雪崩

#### 雪崩

1. 均匀设置过期时间
2. 互斥锁，如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存，实现互斥锁的时候，最好设置**超时时间**，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，造成死锁
3. 双key，一个有ttl，一个没有

#### 击穿（key过期瞬间击穿）

1. 互斥锁
2. 不设置过期时间，后台异步更新缓存。或者过期前用MQ通知后台更新

#### 穿透（value不存在）

1. 限制非法请求
2. 布隆过滤器
3. 缓存null

### 布隆过滤器

假设集合里面有 3 个元素 {x, y, z}，哈希函数的个数为 3。首先将位数组进行初始化，将里面每个位都设置为 0。对于集合里面的每一个元素，将元素依次通过 3 个哈希函数进行映射，每次映射都会产生一个哈希值，这个值对应位数组上面的一个点，然后将位数组对应的位置标记为 1，查询 W 元素是否存在集合中的时候，同样的方法将 W 通过哈希映射到位数组上的 3 个点。如果 3 个点的其中有一个点不为 1，则可以判断该元素一定不存在集合中。反之，如果 3 个点都为 1，则该元素可能存在集合中。注意：此处不能判断该元素是否一定存在集合中，可能存在一定的误判率。可以从图中可以看到：假设某个元素通过映射对应下标为 4、5、6 这 3 个点。虽然这 3 个点都为 1，但是很明显这 3 个点是不同元素经过哈希得到的位置，因此这种情况说明元素虽然不在集合中，也可能对应的都是 1，这是误判率存在的原因

![](https://mmbiz.qpic.cn/mmbiz_jpg/HrWw6ZuXCsgnSHPeB2OQ2OVV5Ho7jxWkEFmBmUumgenhbmJqjSYHSDWBlm4uLu060aC9U1cia00sfjAMtFVmTPA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

