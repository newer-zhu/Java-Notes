### 过期问题？

**主动和被动**

主动过期，redis每秒随机检查20个key，删除过期的key，如果过期的key多于检测的25%，继续挑选20个key，重复以上步骤。保证任何时刻都有25%的key过期

被动过期，用到一个key之前会检测是否过期

**过期时间？**

过期事件用的是unix的时间戳，保证redis挂了设置的时间依旧流逝。如果两台服务器时钟不一致，RDB在两台服务器之间同步，所有key装载时就过期

**复制AOF文件时如何处理过期？**

![image-20220316145837020](E:\学习笔记\typora\img\image-20220316145837020.png)

**回收策略**

![image-20220316151005478](E:\学习笔记\typora\img\image-20220316151005478.png)

### 单线程模型

1. Redis基于Reactor模式开发了网络事件处理器,这个处理器就叫做文件事件处理器(file event handler).这个文件事件处理器是单线程的,所以Redis才叫做单线程的模型,文件事件处理器采用了IO多路复用机制同时监听多个socket,根据socket上的事件来选择对应的事件处理器来处理这个事件;

2. 如果被监听的[socket](https://so.csdn.net/so/search?q=socket&spm=1001.2101.3001.7020)准备好执行accept,read,write,close等事件/操作的时候,对应的文件事件就会产生,这个时候文件事件处理器就会调用之前关联好的事件处理器来处理这个事件;

3. 文件事件处理器是单线程模式运行的,但是通过IO多路复用机制监听多个socket,可以实现高性能的网络通信模型.又可以跟内部其他单线程的模块进行对接,保证了Redis内部的线程模型的简单性;

4. 文件事件处理器的结构包含4个部分

   > ①.多个socket;
   >
   > ②.IO多路复用程序;
   >
   > ③.文件事件分派器;
   >
   > ④.事件处理器(命令请求处理器,命令回复处理器,连接应答处理器等等);

5. 多个socket可能并发的产生不同的操作,每个操作对应不同的文件事件,但是IO多路复用程序会监听多个socket,会将socket放入一个队列中排队,然后每次从队列中取出一个socket给事件分派器,事件分派器再把socket分派给对应的事件处理器去处理;
6. 当一个socket的事件被处理完之后,IO多路复用程序才会将队列中的下一个socket取出交给事件分派器.文件事件分派器再根据socket当前产生的事件来选择对应的事件处理器来处理;

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190918215924363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hwX3hweHA=,size_16,color_FFFFFF,t_70)

### 分布式

**分布式ID**

1. UUID：无需中央控制器，生成快。索引效率差，占用空间多。IO随机性大。

2. 数据库主键自增：IO写入连续性好，分库分表复杂，数据泄漏，索引速度快

3. redis自增：性能高，数据会丢失和泄漏

4. 雪花算法：不依赖外部组件，缺点是时钟回拨会导致重复

   ![image-20220317211832836](E:\学习笔记\typora\img\image-20220317211832836.png)

### redis底层实现数据结构

![](E:\学习笔记\typora\img\redisb.png)

### redis用作消息队列

![image-20220505223722201](E:\学习笔记\typora\img\image-20220505223722201.png)

### 缓存击穿、穿透、雪崩

#### 雪崩

1. 均匀设置过期时间
2. 互斥锁，如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存，实现互斥锁的时候，最好设置**超时时间**，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，造成死锁
3. 双key，一个有ttl，一个没有

#### 击穿（key过期瞬间击穿）

1. 互斥锁
2. 不设置过期时间，后台异步更新缓存。或者过期前用MQ通知后台更新

#### 穿透（value不存在）

1. 限制非法请求
2. 布隆过滤器
3. 缓存null



