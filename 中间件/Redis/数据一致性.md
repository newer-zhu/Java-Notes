## 一致性

**四种策略**

- 在 Cache-Aside 中，应用程序负责从数据源中获取数据并更新到缓存。

- 在 Read-Through 中，此逻辑通常是由独立的缓存提供程序（Cache Provider）支持。

- Write-Through策略下，当发生数据更新(Write)时，缓存提供程序 `Cache Provider` 负责更新底层数据源和缓存。

- Write behind在一些地方也被称为Write back， 简单理解就是：应用程序更新数据时只更新缓存， Cache Provider每隔一段时间将数据刷新到数据库中。说白了就是`延迟写入`。

**具体实现**

不删除缓存的方案，先==更新数据库，后更新缓存==

1. 线程 A 更新数据库（X = 1）
2. 线程 B 更新数据库（X = 2）
3. 线程 B 更新缓存（X = 2）
4. 线程 A 更新缓存（X = 1）

最终 X 的值在缓存中是 1，在数据库中是 2，发生不一致。

这种方案还会浪费机器性能，每次都无脑更新缓存。



redis做缓存时，为了并发效果，推荐==先更新数据库，在删除缓存。==

但是如果其中第二步失败了，肯定是无法保证数据一致性的。

但是从并发角度来看

1. 缓存中 X 不存在（数据库 X = 1）
2. 线程 A 读取数据库，得到旧值（X = 1）
3. 线程 B 更新数据库（X = 2)
4. 线程 B 删除缓存
5. 线程 A 将旧值写入缓存（X = 1）

最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），也发生不一致。

这种情况「理论」来说是可能发生的，但实际真的有可能发生吗？

其实概率「很低」，这是因为它必须满足 3 个条件：

1. 缓存刚好已失效
2. 读请求 + 写请求并发
3. 更新数据库 + 删除缓存的时间（步骤 3-4），要比读数据库 + 写缓存时间短（步骤 2 和 5）

由于概率极低，所以可以保证数据一致性

解决了并发，再考虑异常的问题。对于第二步失败引发的问题，可以重试，但是需要考虑一下几个问题

- 立即重试很大概率「还会失败」
- 「重试次数」设置多少才合理？
- 重试会一直「占用」这个线程资源，无法服务其它客户端请求

所以要把重试这个操作放在另外一个服务，把重试这个消息放入消息队列，并保证以下：

- **消息队列保证可靠性**
- **消息队列保证消息成功投递**

如果你确实不想在应用中去写消息队列，是否有更简单的方案，同时又可以保证一致性呢？

方案还是有的：**订阅数据库变更日志，再操作缓存**。

当一条数据发生修改时，MySQL 就会产生一条变更日志（Binlog），我们可以订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。

## 延迟双删

此为有主从库和读写分离的情况下

1. 线程 A 更新主库 X = 2（原值 X = 1）
2. 线程 A 删除缓存
3. 线程 B 查询缓存，没有命中，查询「从库」得到旧值（从库 X = 1）
4. 从库「同步」完成（主从库 X = 2）
5. 线程 B 将「旧值」写入缓存（X = 1）

线程 A 可以生成一条「延时消息」，写到消息队列中，消费者延时「删除」缓存。

但问题来了，这个「延迟删除」缓存，延迟时间到底设置要多久呢？

- 问题1：延迟时间要大于「主从复制」的延迟时间
- 问题2：延迟时间要大于线程 B 读取数据库 + 写入缓存的时间

但是，**这个时间在分布式和高并发场景下，其实是很难评估的**。