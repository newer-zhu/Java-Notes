1. Math.round(),四舍五入的原理是在参数上加 0.5 然后进行下取整。

2. float f=3.4, 不正确。需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F

3. short s1 = 1; s1 = s1 + 1; 强制转换

   short s1 = 1; s1 += 1; 隐式转换

   

4. - private : 在同一类内可见。使用对象：变量、方法。注意：不能修饰类（外部类）
   - default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修- 饰符。使用对象：类、接口、变量、方法。
   - protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。注意：不能修饰类（外部类）。
   - public : 对所有类可见。使用对象：类、接口、变量、方法

   

6. finalize是一个方法，属于Object类的一个方法，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。

7. #### **this与super的区别**

   - super()和this()均需放在构造方法内第一行。
   - 尽管可以用this调用一个构造器，但却不能调用两个。
   - this()和super()不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。
   - this()和super()都指的是对象，所以，均不可以在static环境中使用。
   - 从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。

7. #### **static注意事项**

   1、静态只能访问静态。2、非静态既可以访问非静态的，也可以访问静态的

   

10. **抽象类和接口**

    - 抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。

    - 接口的字段默认都是 static 和 final 的

    - 接口只能继承接口，且不能实现另一个接口

    - jdk7接口引入常量和抽象方法

    - jdk8接口引入默认方法和静态方法

      接口冲突：一个类的父类和实现的接口同名同参但返回值不同

    - jdk9后接口可以有private方法

    

11. **局部变量**：没有默认初始值，使用前必须赋值。

10. #### **在Java中定义一个不做事且没有参数的构造方法的作用**

    Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。

    *关于构造方法：如果手动定义了几个构造方法，那么类就存在几个构造方法。如果没有编写任何构造方法，会有默认的无参构造。如只定义了一个带参的构造方法，那么这个类就不会有无参构造。*

    

11. 内部类可以分为四种：**成员内部类、局部内部类、匿名内部类和静态内部类**。

    局部内部类：

    局部内部类和匿名内部类要使用方法里的变量的时候这个变量必须是final的（new的局部内部类在堆内存中，变量跟随方法在栈内存中。生命周期不一致）

    匿名内部类：

    - 匿名内部类必须继承一个抽象类或者实现一个接口。
    - 匿名内部类不能定义任何静态成员和静态方法。
    - 当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。
    - 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。

    内部类好处：

    - 一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！
    - 内部类不为同一包的其他类所见，具有很好的封装性；
    - 内部类有效实现了“多重继承”，优化 java 单继承的缺陷。
    - 匿名内部类可以很方便的定义回调。

12. == 和 equals

    情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。

    情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。
    
    
    
15. #### **String str="i"与 String str=new String(“i”)一样吗？**

    不一样，因为内存的分配方式不一样。String str="i"的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。

16. #### **在使用 HashMap 的时候，用 String 做 key 有什么好处？**

    HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。

    

17. Double. MIN_VALUE 和 Double. MAX_VALUE 一样，都是正数

18. 在 try 块或者 catch 语句中执行 return 语句时，finally 语句会执行；在 try 块或者 catch 语句中执行 `System.exit()` 时，finally 语句不会执行

    

19. 方法重写适用于动态绑定，因此静态方法无法被重写

    

20. 通常情况下，我们在调用 `getBytes()` 方法时，要指定编码，没有指定编码的时候，JDK 会调用平台默认的字符编码，而不同的操作系统，编码不尽相同的

    

21. RuntimeException 和 NullPointerException 属于不检查异常，子类重写父类方法时，可检查（checked）异常必须在源代码中显式地进行捕获处理，不检查（unchecked）异常就是所谓的运行时异常

    

20. 不能使用减法来比较整数值，因为减法的结果可能溢出。应该使用 `Integer.compareTo()` 来进行比较

    

21. finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。