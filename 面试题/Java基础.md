2. float f=3.4, 不正确。需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F

3. short s1 = 1; s1 = s1 + 1; 强制转换

   short s1 = 1; s1 += 1; 隐式转换

   

4. - private : 在同一类内可见。使用对象：变量、方法。注意：不能修饰类（外部类）
   - default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修- 饰符。使用对象：类、接口、变量、方法。
   - protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。注意：不能修饰类（外部类）。
   - public : 对所有类可见。使用对象：类、接口、变量、方法

   

5. #### **this与super的区别**

   - super()和this()均需放在构造方法内第一行。
   - 尽管可以用this调用一个构造器，但却不能调用两个。
   - this()和super()不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。
   - this()和super()都指的是对象，所以，均不可以在static环境中使用。
   - 从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。

   

10. #### **在Java中定义一个不做事且没有参数的构造方法的作用**

    Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。

    *关于构造方法：如果手动定义了几个构造方法，那么类就存在几个构造方法。如果没有编写任何构造方法，会有默认的无参构造。如只定义了一个带参的构造方法，那么这个类就不会有无参构造。*

    

6. 内部类可以分为四种：**成员内部类、局部内部类、匿名内部类和静态内部类**。

   局部内部类：

   局部内部类和匿名内部类要使用方法里的变量的时候这个变量必须是final的（new的局部内部类在堆内存中，变量跟随方法在栈内存中。生命周期不一致）

   匿名内部类：

   - 匿名内部类必须继承一个抽象类或者实现一个接口。
   - 匿名内部类不能定义任何静态成员和静态方法。
   - 当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。
   - 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。

   内部类好处：

   - 一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！
   - 内部类不为同一包的其他类所见，具有很好的封装性；
   - 内部类有效实现了“多重继承”，优化 java 单继承的缺陷。
   - 匿名内部类可以很方便的定义回调。

   

13. RuntimeException 和 NullPointerException 属于不检查异常，子类重写父类方法时，可检查（checked）异常必须在源代码中显式地进行捕获处理，不检查（unchecked）异常就是所谓的运行时异常

    

14. 不能使用减法来比较整数值，因为减法的结果可能溢出。应该使用 `Integer.compareTo()` 来进行比较
