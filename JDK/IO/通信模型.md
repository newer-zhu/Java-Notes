# 三种通信模型

- **BIO (Blocking I/O):** 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。
- **NIO (New I/O):** NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架。NIO提供了与传统BIO模型中的 `Socket` 和 `ServerSocket` 相对应的 `SocketChannel` 和 `ServerSocketChannel` 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。
- **AIO (Asynchronous I/O):** AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。

## NIO

**通道Channel**

由输入/出流获取，数据从通道读取到缓冲区里

聚集：多个缓冲区集中到一个通道(read方法)

分散：一个通道发送到多个缓冲区(write方法)

**缓冲区Buffer**

limit之后的部分不可操作

注意flip()方法，进行读写状态的转变，clear()方法对buffer的参数重置

clear()方法只是把指针移到开头，后续增加数据才去覆盖

基于直接内存的缓冲区会绕过堆内存，申请慢，但是IO快，效率高，适合大数据。MappedByteBuffer可以让文件在堆外内存直接修改，可以提高性能

**选择器selector**

通道注册到选择器，指定监听接受事件，轮询多个通道

selector是一个抽象类，里面有个set存着selectkey

当channel注册进selector时就会和selectkey关联

调用selector.select()时会阻塞

### 步骤

**服务端：**

获取Channel， 将通道切换为非阻塞模式，绑定连接的端口，获取选择器

将通道注册到选择器，指定监听接受事件

while循环轮询通道中是否有就绪好的事件，获取事件迭代器

获取当前事件，判断事件具体内容

1. isAcceptable接入事件： 获取接入的客户端通道，切换非阻塞模式，注册读事件
2. isReadable读事件：获取当前事件通道，读取数据

事件迭代器移除当前事件

**客户端**

获取通道， 切换成非阻塞模式

通道中写入数据