## 作用

- 保证指令不会受到上下文切换的影响

- 保证指令不会受cpu缓存的影响

- 保证指令不会受cpu指令并行优化的影响

**volatile不能解决指令交错，仅用在一个线程写，多个线程读的情况。volatile不能保证原子性**

例如：==1、线程读取i 2、temp = i + 1 3、i = temp 当 i=5 的时候A,B两个线程同时读入了 i 的值， 然后A线程执行了 temp = i + 1的操作， 要注意，此时的 i 的值还没有变化，然后B线程也执行了 temp = i + 1的操作，注意，此时A，B两个线程保存的 i 的值都是5，temp 的值都是6， 然后A线程执行了 i = temp （6）的操作，此时i的值会立即刷新到主存并通知其他线程保存的 i 值失效， 此时B线程需要重新读取 i 的值那么此时B线程保存的 i 就是6，同时B线程保存的 temp 还仍然是6， 然后B线程执行 i=temp （6），所以导致了计算结果比预期少了1==

在以下两个场景中可以使用volatile来代替synchronized：

1、运算结果并不依赖变量的当前值，或者能够确保只有单一的线程会修改变量的值。

2、变量不需要与其他状态变量共同参与不变约束。

### volatile的实现

**可见性**

写屏障（加在写操作之后）：在该屏障之前会把共享变量的改动都同步到主存中

读屏障（加在读操作之前）：在该屏障之后对共享变量的读取都是从主存中获得

读写屏障不能解决指令交错，写屏障不能保证之后的读操作跑到写屏障之前，而是保证屏障之后的每次读都能读到最新值

**有序性**也只能保证本线程内volatile相关代码不被重排

*final原理就是加了写屏障，如果一个静态变量使用final关键字，会直接复制一份值使用，否则会getStatic去获取值。*

## 相关概念

### 线程缓存

如果线程中需要频繁去主存中读取变量，就会在线程中开启高速内存储存变量。变量加了volatile就不会被加入缓存。保证其可见性，synchronized也可以保证其可见性。

### 缓存行对齐

一个缓存行大小是64Byte，读取缓存会按照缓存行读取。当被volatile修饰的多个变量存在同一个缓存行且其中一个被修改时，CPU会通知另一个线程重新读取这个缓存行。如果一个类中填充一些变量使这个类被存在不同缓存行就会提高效率

### 指令重排

CPU会自动重排序数条前后执行顺序对运行结果无影响的指令，由于一条指令可以被分成五个部分，CPU为了吞吐量把使用不同资源的部分串行执行，这就是指令流水技术。但这种技术不会缩短单个指令的时间长度。

*单例模式的double check单例需要加volatile，否则发送指令重排会拿到半初始化的对象。因为new 一个对象分为三步，分别是分配出对象的堆空间并赋默认值，执行构造方法，建立栈中变量和堆中空间的联系。第二三步可能发生指令重排*

