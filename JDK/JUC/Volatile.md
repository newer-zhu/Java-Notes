## 内存模型

Java 内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。

## MESI

MESI中每个缓存行都有四个状态，分别是E（exclusive）、M（modified）、S（shared）、I（invalid）。下面我们介绍一下这四个状态分别代表什么意思。

M：代表该缓存行中的内容被修改了，并且该缓存行只被缓存在该CPU中。这个状态的缓存行中的数据和内存中的不一样，在未来的某个时刻它会被写入到内存中（当其他CPU要读取该缓存行的内容时。或者其他CPU要修改该缓存对应的内存中的内容时（个人理解CPU要修改该内存时先要读取到缓存中再进行修改），这样的话和读取缓存中的内容其实是一个道理）。

E：E代表该缓存行对应内存中的内容只被该CPU缓存，其他CPU没有缓存该缓存对应内存行中的内容。这个状态的缓存行中的内容和内存中的内容一致。该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态。

S:该状态意味着数据不止存在本地CPU缓存中，还存在别的CPU的缓存中。这个状态的数据和内存中的数据是一致的。当有一个CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态。

I：代表该缓存行中的内容时无效的。

![image-20220311135731773](E:\学习笔记\typora\img\image-20220311135731773.png)

## Happens-Before

- 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
- 锁定规则：一个 unLock 操作先行发生于后面对同一个锁额 lock 操作
- volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
- 传递规则：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作C
- 线程启动规则：Thread 对象的 `start()` 方法先行发生于此线程的每个一个动作
- 线程中断规则：对线程`interrupt()`方法的调用先行发生于被中断线程的代码检测到中断事件的发生
- 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过 `Thread.join()` 方法结束、`Thread.isAlive()`的返回值手段检测到线程已经终止执行
- 对象终结规则：一个对象的初始化完成先行发生于他的`finalize()`方法的开始

## 作用

- 保证指令不会受到上下文切换的影响

- 保证指令不会受cpu缓存的影响

- 保证指令不会受cpu指令并行优化的影响

**volatile不能解决指令交错，仅用在一个线程写，多个线程读的情况。**

例如：==1、线程读取i 2、temp = i + 1 3、i = temp 当 i=5 的时候A,B两个线程同时读入了 i 的值， 然后A线程执行了 temp = i + 1的操作， 要注意，此时的 i 的值还没有变化，然后B线程也执行了 temp = i + 1的操作，注意，此时A，B两个线程保存的 i 的值都是5，temp 的值都是6， 然后A线程执行了 i = temp （6）的操作，此时i的值会立即刷新到主存并通知其他线程保存的 i 值失效， 此时B线程需要重新读取 i 的值那么此时B线程保存的 i 就是6，同时B线程保存的 temp 还仍然是6， 然后B线程执行 i=temp （6），所以导致了计算结果比预期少了1==

在以下两个场景中可以使用volatile来代替synchronized

1、运算结果并不依赖变量的当前值，或者能够确保只有单一的线程会修改变量的值。

2、变量不需要与其他状态变量共同参与不变约束。

### volatile的实现

**可见性**

写屏障：在该屏障之前会把共享变量的改动都同步到主存中

读屏障：在该屏障之后对共享变量的读取都是从主存中获得

读写屏障不能解决指令交错，写屏障不能保证之后的读操作跑到写屏障之前，而是保证屏障之后的每次读都能读到最新值

**有序性**也只能保证本线程内volatile相关代码不被重排

*final原理就是加了写屏障，如果一个静态变量使用final关键字，会直接复制一份值使用，否则会getStatic去获取值。*

当volatile修饰的变量进行写操作的时候，JVM就会向CPU发送LOCK#前缀指令，此时当前处理器的缓存行就会被锁定，通过缓存一致性机制确保修改的原子性，然后更新对应的主存地址的数据。

处理器会使用嗅探技术保证在当前处理器缓存行，主存和其他处理器缓存行的数据的在总线上保持一致。在JVM通过LOCK前缀指令更新了当前处理器的数据之后，其他处理器就会嗅探到数据不一致，从而使当前缓存行失效，当需要用到该数据时直接去内存中读取，保证读取到的数据时修改后的值。

### 底层实现

lock 前缀指令实际上相当于一个内存屏障（也称内存栅栏），内存屏障会提供 3 个功能

- 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
- 它会强制将对缓存的修改操作立即写入主存；
- 如果是写操作，它会导致其他 CPU 中对应的缓存行无效。

## 相关概念

### 线程缓存

如果线程中需要频繁去主存中读取变量，就会在线程中开启高速缓存储存变量。变量加了volatile就不会被加入缓存。

### 缓存行对齐

一个缓存行大小是64Byte，读取缓存会按照缓存行读取。当被volatile修饰的多个变量存在同一个缓存行且其中一个被修改时，CPU会通知另一个线程重新读取这个缓存行。如果一个类中填充一些变量使这个类被存在不同缓存行就会提高效率

### 指令重排

CPU会自动重排序数条前后执行顺序对运行结果无影响的指令，由于一条指令可以被分成五个部分，CPU为了吞吐量把使用不同资源的部分串行执行，这就是指令流水技术。

*单例模式的double check单例需要加volatile，否则发送指令重排会拿到半初始化的对象。因为new 一个对象分为三步，分别是分配出对象的堆空间并赋默认值，执行构造方法，建立栈中变量和堆中空间的联系。第二三步可能发生指令重排*





