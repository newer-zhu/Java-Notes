> 同步不一定阻塞，异步也不一定非阻塞。没有必然关系

在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。

在Java NIO中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。

在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作

**同步和异步：**同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO 操作并等待或者轮询的去查看IO 操作是否就绪，而异步是指用户进程触发IO 操作以后便开始做自己的事情，而当IO 操作已经完成的时候会得到IO 完成的通知。

**同步** ： 使用同步 IO 时，Java 自己处理IO 读写

**异步** ： 使用异步IO 时，Java 将 IO 读写委托给OS 处理，需要将数据缓冲区地址和大小传给OS，OS 需要支持异步IO操作API

**阻塞和非阻塞：**阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作方法的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入方法会立即返回一个状态值。

**LINUX五种IO模型**

1. 阻塞式IO
2. 非阻塞式IO
3. IO多路复用
4. 信号驱动 
5. 异步IO

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645697176069/15E8A71DD02F5934C2D617340EABD097)

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645697189029/0347B150DCD58A539420C4EEFDA38DDA)

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645697204755/99AAF975C142C12C64599E1CC4EA2A26)

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645697219427/9712953FC0712BDF26B12B1BDB20FEFE)

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645697244750/2DE5E6A07632CB924A60FF35C1183DEB)

前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。

两种寄存器编址方式：内存映射，寄存器独立编址

![image-20220408002533156](E:\学习笔记\typora\img\image-20220408002533156.png)

**IO控制方式**

1. 程序直接控制：需要轮询状态寄存器
2. 中断：CPU和IO设备可以并行运行，中断效率较低
3. DMA：数据传送单位变成块而非字，数据无需经过内存，直接在内存和IO设备之间流转
4. 通道方式：通道相当于代理CPU，可以处理一些IO指令，与CPU共享内存