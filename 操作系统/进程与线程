## 进程

进程有独立的地址空间,线程有自己的堆栈和局部变量,但线程之间没有单独的地址空间；

一个线程奔溃后整个进程都会死掉，所以多进程比多线程更健壮;

**协程与线程的区别**

1) 一个线程可以多个协程，一个进程也可以单独拥有多个协程。 2) 线程进程都是同步机制，而协程则是异步。 3) 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。 4）线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。 5）协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行, 线程是协程的资源, 但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor), 执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程.。 6）线程是协程的资源。协程通过Interceptor来间接使用线程这个资源。

**僵尸进程和孤儿进程**

1. 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
2. 僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。

**程序并发执行的本质是OS的中断机制。**

![image-20220316163843417](E:\学习笔记\typora\img\image-20220316163843417.png)

**PCB**

进程控制块，用于OS找到要执行的程序内存。==进程实体由程序段、数据段、PCB构成。==

![image-20220316165130185](E:\学习笔记\typora\img\image-20220316165130185.png)

**进程组织方式**

![image-20220316165313272](E:\学习笔记\typora\img\image-20220316165313272.png)

**什么是原语？**

特殊的程序，具有原子性，处于OS的底层，最接近硬件，运行在核心态。

**进程的创建**

![image-20220316170800035](E:\学习笔记\typora\img\image-20220316170800035.png)

**进程间的通信**

1. 共享内存，需要加锁

2. 内存映射 内存映射（Memory-mapped I/O）是将磁盘文件的数据映射到内存,用户通过修改内存就能修改磁盘文件

3. 管道通信，互斥访问，半双工通信。读进程只能有一个。管道里放的是字符，空了读阻塞，满了写阻塞

   无名管道只能用于具有亲缘关系的进程间的通信

4. 消息队列 消息队列就是一个消息的链表,可以把消息看作一个记录,具有特定的格式以及特定的优先级,对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息,对消息队列有读权限的进程则可以从消息队列中读走消息

5. 信号，又称软件中断,它是在软件层次上对中断机制的一种模拟,是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断,转而处理某一个突发事件

6. Socket 套接字（Socket）,就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象

7. 信号量 对信号量的操作分为 P 操作和 V 操作,P 操作是将信号量的值减 1,V 是将信号量的值加 1。

**进程状态**

![image-20220316173304683](E:\学习笔记\typora\img\image-20220316173304683.png)

**进程调度**

![image-20220316175206707](E:\学习笔记\typora\img\image-20220316175206707.png)

进程只有在处于内核临界区时才不能进行处理及调度，如临界资源是进程就绪队列时。

**调度算法**

1. 先来先得 对短作业来说不友好，不会导致饥饿

2. 短作业优先，新进程入队会选择就绪队列中**剩余时间**最短的进程运行。此算法的平均等待时间和平均周转时间比其他算法较短。会导致饥饿现象，短作业一直抢占长作业的时间。可以是抢占式或者非抢占式

3. 高响应比优先，响应比 = （等待时间 + 真正运行时间） /  真正运行时间。是非抢占式的

4. 时间片流转，时间片太大就会退化为先来先得算法

5. 优先级调度，有抢占式和非抢占式。系统进程优先用户，前台进程优先后台，IO型偏向于CPU型

6. 多级反馈队列调度，会导致饥饿

   ![image-20220317165500432](E:\学习笔记\typora\img\image-20220317165500432.png)

**进程互斥**

- 软件算法

  1. 单标志法，设置标记位表示某个进程想进入临界区，while判断，退出后改变标记位。CPU空闲时未必让线程进入
  2. 双标志先检查法，设置意愿标志位，可能会同时进入临界区
  3. 双标志后检查法，先设置意愿，再while检查，可能会导致都进不了临界区

  4. peterson，双方进程都想进入临界区，某个进程会让出自己的使用意愿，让对方进入
  
- 硬件实现

  1. 中断屏蔽，不适合多核
  2. TestAndSet指令，类似CAS，硬件支持一气呵成
  3. swap指令，逻辑和2一样
  
- 信号量机制
  1. 整形信号量：表示资源的数量，wait，signal原语实现原子性，P，V分别代表这两种方法
  2. 记录型信号量：数据结构里存了资源数value和等待队列，value < 0 进入block
  
  **互斥：先P后V**
  
  **同步：先V后P**
  
  

## 线程

**线程实现方式**

1. 用户线程，切换在用户态下就可以完成
2. 内核线程，需要在核心态下切换。对OS来说内核级线程才是资源分配的对象。
3. 混合线程，把用户线程切换到内核线程，有应用程序负责用户线程的切换。有多对一，一对一，多对多模型

