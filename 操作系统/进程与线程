## 进程

**程序并发执行的本质是OS的中断机制。**

![image-20220316163843417](E:\学习笔记\typora\img\image-20220316163843417.png)

**系统调用**

涉及到共享资源的操作由OS对外提供函数来进行操作

**PCB**

进程控制块，用于OS找到要执行的程序内存。==进程实体由程序段、数据段、PCB构成。==

![image-20220316165130185](E:\学习笔记\typora\img\image-20220316165130185.png)

**进程组织方式**

![image-20220316165313272](E:\学习笔记\typora\img\image-20220316165313272.png)

**状态**

运行、就绪、阻塞

就绪状态只差CPU，阻塞状态连其他所需资源也没有

**什么是原语？**

特殊的程序，具有原子性，处于OS的底层，最接近硬件，运行在核心态。

**进程的创建**

![image-20220316170800035](E:\学习笔记\typora\img\image-20220316170800035.png)

**进程间的通信**

1. 共享空间，需要加锁
2. 管道通信，互斥访问，半双工通信。读进程只能有一个。管道里放的是字符，空了读阻塞，满了写阻塞
3. 消息传递，直接通信挂到接收进程的消息缓存队列，间接通信会有中间实体"信箱"

**进程状态**

![image-20220316173304683](E:\学习笔记\typora\img\image-20220316173304683.png)

**进程调度**

![image-20220316175206707](E:\学习笔记\typora\img\image-20220316175206707.png)

进程只有在处于内核临界区时才不能进行处理及调度，如临界资源是进程就绪队列时。

处于原语操作，处理中断过程中也不能进行线程调度。

**调度算法**

1. 先来先得 对短作业来说不友好，不会导致饥饿

2. 短作业优先，新进程入队会选择就绪队列中**剩余时间**最短的进程运行。此算法的平均等待时间和平均周转时间比其他算法较短。会导致饥饿现象，短作业一直抢占长作业的时间。可以是抢占式或者非抢占式

3. 高响应比优先，响应比 = （等待时间 + 真正运行时间） /  真正运行时间。是非抢占式的

4. 时间片流转，时间片太大就会退化为先来先得算法

5. 优先级调度，有抢占式和非抢占式。系统进程优先用户，前台进程优先后台，IO型偏向于CPU型

6. 多级反馈队列调度，会导致饥饿

   ![image-20220317165500432](E:\学习笔记\typora\img\image-20220317165500432.png)

**进程互斥**

原则：空闲让进，忙则等待，有限等待，让权等待

- 软件算法

  1. 单标志法，设置标记位表示某个进程想进入临界区，while判断，退出后改变标记位。CPU空闲时未必让线程进入
  2. 双标志先检查法，设置意愿标志位，可能会同时进入临界区
  3. 双标志后检查法，先设置意愿，再while检查，可能会导致都进不了临界区

  4. peterson，双方进程都想进入临界区，某个进程会让出自己的使用意愿，让对方进入
  
- 硬件实现

  1. 中断屏蔽，不适合多核
  2. TestAndSet指令，类似CAS，硬件支持一气呵成
  3. swap指令，逻辑和2一样
  
- 信号量机制
  1. 整形信号量：表示资源的数量，wait，signal原语实现原子性，P，V分别代表这两种方法
  2. 记录型信号量：数据结构里存了资源数value和等待队列，value < 0 进入block
  
  **互斥：先P后V**
  
  **同步：先V后P**

在临界区前后加上P(mutex)和V(mutex)可以实现原子性

## 线程

**线程实现方式**

1. 用户线程，切换在用户态下就可以完成
2. 内核线程，需要在核心态下切换。对OS来说内核级线程才是资源分配的对象。
3. 混合线程，把用户线程切换到内核线程，有应用程序负责用户线程的切换。有多对一，一对一，多对多模型

