## 索引：一种排序后的快速查找的数据结构

劣势：占用空间，影响CRUD的操作速度

![image-20210821131728503](E:\学习笔记\typora\img\image-20210821131728503.png)

在 MySQL数据库的 InnoDB存储引擎中，**主键索引就是聚集索引**，所有数据都会按照主键索引进行组织；而在MyISAM存储引擎中，就没有聚集索引了，因为MyISAM存储引擎中的数据不是按索引顺序进行存储的。聚集索引叶子上全是表的数据，我们自定义的索引都是二级索引，是为了找到聚集索引而设置的。

### B+树

### 索引分类

1. 单列索引（主键索引,唯一索引,普通索引)
3. 复合索引

### 语法

```sql
create index [index_name] on table_name(column) 

show index from table_

drop index index_name on table_name

alter table table_name add index index_name(column)
```

*频繁查询应建索引，频繁更新无需建索引。与其它表关联的字段，统计分组字段需建索引*

### 最左匹配原则

从最左列开始，不跳过索引中间列查询

### 索引失效

- 范围查询后的字段会失效
- 索引列上做操作会导致索引失效
- 字符串不加单引号会失效
- or条件会导致索引失效，可以用union替代
- 模糊查询%开头的会失效，可以用覆盖索引
- 如果使用索引比不用慢，则mysql会不使用索引
- is null 和 is not null也会导致索引失效，不过得根据null值多少来决定
- in走索引，not in不走索引
- 使用不等于<>条件时会全表扫描
- order by后字段的顺序与索引顺序不一样会导致内排序， order by和group by会用上索引但不统计在key_len中

优化：

- 尽量使用数字型字段
- 尽量使用主键查询，这样不会触发回表查询
- 用exists代替in
- 避免在索引列上使用is null或is not null
- 大语句拆小语句

### filrsort

一次扫描法：一次排序，排序后直接输出结果集，效率高，内存开销打

二次扫描法：根据条件取出排序字段和行指针，在sort buffer中排序，在临时表中储存结果，会导致大量随机IO

增大max_length_for_sort_data和sort_buffer_size大小提高排序效率

### 相关语句

select * from tb_name use index() 指定某个索引

select * from tb_name ignore index() 忽略某个索引

select * from tb_name force index() 强制使用某个索引

### 索引下推

一句话说就是把索引列的判断条件交给了索引引擎判断，而不是server，减少了回表查询的记录数量

- 在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。
- 在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。
- 索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。
