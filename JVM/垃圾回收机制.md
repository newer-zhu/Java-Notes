## 概念

**并行**

用户线程会被暂停，多条垃圾回收线程一起执行

**并发**

用户线程和垃圾回收线程交替执行

## 标记算法

1. 引用计数法：致命，无法解决循环引用。A -> B <=> C,, A -> null.

2. 可达性分析

   GC Roots对象

   ![image-20220310162937855](E:\学习笔记\typora\img\image-20220310162937855.png)

**finalize**

![image-20220310164121212](E:\学习笔记\typora\img\image-20220310164121212.png)

finalize未被重写或已被jvm调用过则进入不可触及状态，如果重写了或未被调用就会进入低优先级队列中等待调用此方法

**清除算法**

1. 标记清除（清除并非直接置空，而是放入空闲列表，下一次分配时直接覆盖）
2. 标记-复制
3. 标记-整理（相当于标记清除后进行一次内存碎片整理，会导致对象的移动，移动过程会stop the world）

**内存泄漏**

1. 资源未关闭，如IO操作
2. 长时间存活的对象关联的对象过多

**Safe Point**

方法调用，循环进入，异常跳转

![image-20220311110224137](E:\学习笔记\typora\img\image-20220311110224137.png)

线程sleep或block时处于安全区域，对象引用不会改变

## 对象消失

对象消失的条件：

1：赋值器插入了一条或者多条从黑色对象到白色对象的新引用。 ------->增量更新

2：赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。------->原始快照

**增量更新**要破坏的是第一个条件（赋值器插入了一条或者多条从黑色对象到白色对象的新引用），当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。可以简化的理解为：黑色对象一旦插入了指向白色对象的引用之后，它就变回了灰色对象。

**原始快照**要破坏的是第二个条件（赋值器删除了全部从灰色对象到该白色对象的直接或间接引用），当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这个可以简化理解为：无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照开进行搜索。不会因为用户线程修改了引用而将其对象回收。因为在扫描开始的时候只要有对象树上面有变动就会被记录
————————————————

## 垃圾回收器

![image-20220312132101303](E:\学习笔记\typora\img\image-20220312132101303.png)

垃圾回收器的组合

![image-20220312164236465](E:\学习笔记\typora\img\image-20220312164236465.png)

G1在JDK9之后启用，Parallel在JDK8中为默认

**Serial**

新生代回收采用复制算法，串行回收。简单高效

Serial Old 采用标记-整理算法。可以与Prallel配合，或者作为CMS的后背方案。

**ParNew**

并行回收，也会产生STW，也是复制算法。串行回收老年代，标记-整理算法。老年代配合CMS

**Parallel**

重点放在吞吐量，拥有自适应调节能力，适合后台运算服务

**CMS**

JDK14后直接删除了CMS

初始标记（STW） -> 并发标记 -> 重新标记（STW） -> 并发清理 -> 重置线程

采用标记-清除算法，并发标记采用的是增量更新避免对象消失问题（黑变白），为了保证用户线程的正常执行，避免移动对象。但会导致内存碎片，最后启用Serial进行full GC

无法处理浮动垃圾（GC时用户线程产生的新垃圾），在堆内存到达一定阈值就GC，为了让用户线程有足够内存可用。

**G1**

region方式回收，一个region只有一个角色。根据设置的允许回收事件，选择价值最大的优先回收，后台维护了优先列表记录区域的回收价值。还有一个特殊区域为Humongous用来存放超过region一半大小的大对象。

region之间是复制算法，整体式标记压缩的算法。堆空间越大，回收效率越高。

会占用较多的内存框架去维护双向卡表（我指向谁，谁指向我），key为别的region起始地址，value为一个set,储存是卡表的索引号。即记录那些跨region的引用。

标记使用原始快照算法，写前屏障跟踪指针变化。CMS的写屏障类似于同步，但是G1需要跟踪的变化指针太多，只能将其实现为消息队列的形式。

