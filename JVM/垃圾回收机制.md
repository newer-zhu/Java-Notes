

## 标记算法

1. 引用计数法：致命，无法解决循环引用。A -> B <=> C,, A -> null.

2. 可达性分析

   GC Roots对象

   ![image-20220310162937855](E:\学习笔记\typora\img\image-20220310162937855.png)

**finalize**

![image-20220310164121212](E:\学习笔记\typora\img\image-20220310164121212.png)

finalize未被重写或已被jvm调用过则进入不可触及状态，如果重写了或未被调用就会进入低优先级队列中等待调用此方法

**Safe Point**	方法调用，循环进入，异常跳转

![image-20220311110224137](E:\学习笔记\typora\img\image-20220311110224137.png)

线程sleep或block时处于安全区域，对象引用不会改变

## 三色标记

对象消失的条件

1：赋值器插入了一条或者多条从黑色对象到白色对象的新引用。 ------->增量更新

2：赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。------->原始快照

**增量更新**要破坏的是第一个条件（赋值器插入了一条或者多条从黑色对象到白色对象的新引用），当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。可以简化的理解为：黑色对象一旦插入了指向白色对象的引用之后，它就变回了灰色对象。

**原始快照**要破坏的是第二个条件（赋值器删除了全部从灰色对象到该白色对象的直接或间接引用），当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这个可以简化理解为：无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照开进行搜索。不会因为用户线程修改了引用而将其对象回收。因为在扫描开始的时候只要有对象树上面有变动就会被记录
————————————————

## Full/Minor GC

**full gc 触发条件有哪些？**

- 在要进行 young gc 的时候，根据之前统计数据发现年轻代平均晋升大小比现在老年代剩余空间要大，那就会触发 full gc。
- 有永久代的话如果永久代满了也会触发 full gc。
- 老年代空间不足，大对象直接在老年代申请分配，如果此时老年代空间不足则会触发 full gc。
- 担保失败即 promotion failure，新生代的 to 区放不下从 eden 和 from 拷贝过来对象，或者新生代对象 gc 年龄到达阈值需要晋升这两种情况，老年代如果放不下的话都会触发 full gc。
- 执行 System.gc()、jmap -dump 等命令会触发 full gc。

**新生代的 GC 如何避免全堆扫描？**

在常见的分代 GC 中就是利用记忆集来实现的，记录可能存在的老年代中有新生代的引用的对象地址，来避免全堆扫描。

## 垃圾回收器

![image-20220312132101303](E:\学习笔记\typora\img\image-20220312132101303.png)

垃圾回收器的组合

![image-20220312164236465](E:\学习笔记\typora\img\image-20220312164236465.png)

G1在JDK9之后启用，Parallel在JDK8中为默认

### Serial

新生代回收采用复制算法，串行回收。简单高效

Serial Old 采用标记-整理算法。可以与Prallel配合，或者作为CMS的后背方案。

### ParNew

会产生STW，也是复制算法。串行回收老年代，标记-整理算法。老年代配合CMS

### Parallel

重点放在吞吐量，拥有自适应调节能力，适合后台运算服务。

**以上的垃圾回收器回收线程和工作线程不能同时进行**

### CMS

JDK14后直接删除了CMS

初始标记（STW） -> 并发标记 -> 重新标记（STW） -> 并发清理 -> 重置线程

- 初始标记阶段：开始一个短暂的STW，只标记roots，单线程
- 并发标记阶段：据说GC大部分时间都浪费在这，所以这一步是和工作线程同时运行的。一边产生垃圾，一边标记垃圾。
- 重新标记阶段：开始一个短暂的STW，把在并发标记阶段，工作线程产生的垃圾重新标记一下，这个STW时间也很短。这个阶段是多线程的。
- 并发清理阶段：工作线程和垃圾回收线程同时运行，把这个时候工作线程产生的垃圾叫做浮动垃圾，浮动垃圾就要等到下一次CMS清理了。

采用标记-清除算法，并发标记采用的是增量更新避免对象消失问题。但会导致内存碎片，最后启用Serial进行full GC

无法处理浮动垃圾（GC时用户线程产生的新垃圾），在堆内存到达一定阈值就GC，为了让用户线程有足够内存可用。

### G 1

mixed gc：这个是 G1 收集器特有的，指的是收集整个年轻代和部分老年代的 GC。

逻辑上分代，物理上不分代。

除了Old，Survivor，Eden区还有Humongous区：放大对象，如果这个对象特别大，可能会跨两个region。

region方式回收，一个region只有一个角色。根据设置的允许回收事件，选择价值最大的优先回收，后台维护了优先列表记录区域的回收价值。还有一个特殊区域为Humongous用来存放超过region一半大小的大对象。

会占用较多的内存框架去维护双向卡表（我指向谁，谁指向我），key为别的region起始地址，value为一个set,储存是卡表的索引号。即记录那些跨region的引用。

标记使用原始快照算法，写前屏障跟踪指针变化。CMS的写屏障类似于同步，但是G1需要跟踪的变化指针太多，只能将其实现为消息队列的形式。

**优点**

- 由于分区的原因,G1可以只选取部分区域进行内存回收,这样缩小了回收的范围,因此对于全局停顿情况的发生也能得到较好的控制
- G1 跟踪各个 Region 里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值),在后台维护一个优先列表,**每次根据允许的收集时间,优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率**。
- 相比于CMS GC,G1未必能做到CMS在最好情况下的延时停顿,但是最差情况要好很多

**什么是 logging write barrier ？**

写屏障其实耗的是应用程序的性能，是在引用赋值的时候执行的逻辑，这个操作非常的频繁，因此就搞了个 logging write barrier。

把写屏障要执行的一些逻辑搬运到后台线程执行，来减轻对应用程序的影响。

在写屏障里只需要记录一个 log 信息到一个队列中，然后别的后台线程会从队列中取出信息来完成后续的操作，其实就是异步思想。

**回收流程**

1、初始标记（initial marking），这个阶段是 STW 的，扫描根集合，标记根直接可达的对象即可。在G1中标记对象是利用外部的bitmap来记录，而不是对象头。

2、并发阶段（concurrent marking）,这个阶段和应用线程并发，从上一步标记的根直接可达对象开始进行 tracing，递归扫描所有可达对象。STAB 也会在这个阶段记录着变更的引用。

3、最终标记（final marking）, 这个阶段是 STW 的，处理 STAB 中的引用。

4、清理阶段（clenaup），这个阶段是 STW 的，根据标记的 bitmap 统计每个 region 存活对象的多少，如果有完全没存活的 region 则整体回收。

对象拷贝阶段（evacuation），这个阶段是 STW 的，是瓶颈。

根据标记结果选择合适的 reigon 组成收集集合（collection set 即 CSet），然后将 CSet 存活对象拷贝到新 region 中。

### ZGC

物理和逻辑都不分代

染色指针

## 调优

重点：最短暂停时间和吞吐量

**需要平衡分代的大小、垃圾回收的次数和停顿时间。**

需要对 GC 进行完整的监控，监控各年代占用大小、YGC 触发频率、Full GC 触发频率，对象分配速率等等。
